# 기능 개발
입력 : 작업 진도 데이터(%)를 담고 있는 리스트 `progresses`, 하루 당 작업 속도를 담고 있는 리스트 `speeds`   
출력 : 하루마다 배포되는 작업의 수를 담은 리스트

* 배포는 하루의 끝에 한번만 진행
* `progresses` list의 element 순서는 배포 순서와 동일
* 작업이 끝났더라도 먼저 진행해야 하는 작업이 끝나지 않았다면 배포 불가

## mine
* 계획
    - 먼저 들어온 작업이 먼저 배포되므로 큐를 사용
    - 작업을 끝내려면 며칠이 필요한지 구하기
        - 처음엔 단순히 `needs = (100 - progress) // speed` 로 needs를 구함
        - 딱 나누어 떨어지지 않는 경우 `//` 연산은 내림을 해서 100이 아니라 99가 됨
        - 그 경우를 `if`문으로 나눔,, 마음에 안들었다
    - queue의 `pop` 연산을 사용해서 제일 먼저 들어온 작업의 남은 작업일을 구한 다음
    - 그 다음 작업일이 `pop`을 통해 얻은 작업일보다 작거나 같다면?
        - 작업이 이미 or 동시에 끝난 것이므로 같은 날에 배포
        - 아니라면 다른 달에 배포해야 함
    - 위 내용을 남은 작업이 없을 때 까지 반복
    - 여기도 역시 마음에 안든다. 같은 내용을 이중으로 `while` 조건으로 쓰는게 별루

## 멋진 코드 #1
* 남은 작업일 구하기
    - 여기서부터 나랑 다름
    - `p`는 100 이하이므로 `p-100`은 항상 음수
    - 음수 내림하면 절댓값은 증가함. `100-p`가 아닌 `p-100`을 `s`로 floor division한 다음
    - 다시 `-`를 취하면 ceil division 이 된다.
    ~~~python
        -((100-p)//s)
    ~~~

* 하루에 몇 개의 작업이 배포되는지 구하기
    - `zip`을 사용해서 `progresses`와 `speeds`를 묶은 후 그 내부에서 바로 처리한다.
        - 나도 `zip`을 쓰긴 썼지만 남은 작업일을 구할 때만 사용, 이후 이중 `while` (답없다)
    - 큐의 데이터를 `list[ list1, int ]>`의 구조로 사용
        - `list1` : 남은 잔여일
        - `int` : 동시에 배포될 작업 수
    - 생각해보면 동시에 배포될 작업의 잔여일을 모두 알고 있을 필요는 없다


## 멋진 코드 #2
- 잔여일을 담고 있는 배열을 따로 사용하지 않음
- 역으로 `time`이라는 하루하루가 지나감을 담고 있는 변수를 사용
- 문제 보자 마자 떠오른 생각과 유사하면서 직관적으로 보기 좋다고 생각

## 멋진 코드 #3
- `daysLeft` : 남은 잔여일. `math.ceil()` 사용
- `try-except` 구문으로 `IndexError` 발생하면 `count`를 정답 리스트 추가
    - 기발하다

---------

## 오늘의 얻음
~~~python
-((100-p)//s)
~~~
