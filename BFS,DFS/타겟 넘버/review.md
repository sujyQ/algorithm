# 타겟 넘버
* 입력 : n개의 음이 아닌 정수 리스트 `numbers`
* 출력 : 타겟 넘버 `target`

* `numbers`에 있는 정수를 더하거나 빼서 타겟 넘버를 만든다.
* 만들 수 있는 조합의 개수를 리턴한다.

## mine
* 이진 트리 구조
    - 루트 노드가 `0`인 트리로 가정
    - `i`레벨의 노드들은 `numbers[i]`에 1과 -1이 곱해진 노드이다.
    - 리프노드가 아닌 노드들의 왼쪽 자식은 -1이 곱해진, 오른쪽 자식은 +1이 곱해진 값
    - 루트 노드부터 시작해서 말단노드까지 탐색하며 다 더한 결과가 `target`과 동일한지 확인한다.
    - DFS
* 재귀함수 `getCount(numbers, target, total, level)`을 통해 가능한 조합을 센다
    - `numbers` : 입력으로 받은 정수 리스트
    - `target` : 입력으로 받은 타겟 넘버
    - `total` : 현재까지의 합
    - `level` : 현재 트리의 어느 레벨에 존재하는지
* 재귀 함수 종료 조건 : 리프 노드일 때 (레벨이 숫자 개수와 동일)
* `count`를 배열로 선언한 것은,, `global` 사용법을 몰랐다,,,
    - 전역변수 지역변수는 알지만 연구하면서 구현할 때는 전역변수를 사용할 일이 없기 때문에
    - 나중에 `global` 키워드 보고 아 맞다,,! 
    - 아는 것과 실전에서 사용하는 것은 다르다 역시
    - 예전에는 문제를 보고 이게 왜 DFS,BFS일까 싶었는데
    - 다시 기초 공부를 하고 풀기 시작하니까 어떻게 풀어야겠다까지 떠오르고 바로 구현, 통과했다.
    - 기초는 정말정말 중요하다.


## 멋진 코드 #1
* 동일하게 재귀함수를 이용했지만,
    - `target`에서 숫자를 빼며 리프 노드일 때 `target`이 0이 되는지 확인
    - `target`이 0이라면 합이 `target`인 것과 동일, 1을 리턴
    - 0이 아니라면 0을 리턴
* 재귀함수의 리턴값을 누적한다.


## 멋진 코드 #2
* `numbers`의 원소에 1과 -1을 곱하는 2가지 경우가 존재
    - 리스트에 담은 후 `itertools.product`로 가능한 조합을 구함
    - `itertools.product`는 중첩 `for`문과 같음
    - 이후 `map(sum, product)`를 통해 구한 조합의 합을 구함
- 구한 조합 중 `target`과 일치하는 값이 얼마나 있는지 확인

## 멋진 코드 #3
* 멋진 코드 #1과 내 코드 그 중간
* `ret` 변수를 선언, `+=` 연산자로 리턴 값을 더한다.
* 전역 변수를 사용하지 않고 리턴을 이용하면 카운트할 수 있다.

----
오늘의 얻음
~~~python
s = list(map(sum, product(*l)))
s.count(target)
~~~

~~~python
ret = 0
ret += dfs(nums, i+1, n+nums[i], t)
ret += dfs(nums, i+1, n-nums[i], t)
return ret
~~~